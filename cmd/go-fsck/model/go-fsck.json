[
  {
    "Package": "model",
    "Imports": [
      "\"bytes\"",
      "\"fmt\"",
      "\"go/ast\"",
      "\"go/parser\"",
      "\"go/printer\"",
      "\"go/token\"",
      "\"golang.org/x/exp/slices\"",
      "\"golang.org/x/tools/go/ast/inspector\"",
      "\"log\"",
      "\"os\"",
      "\"sort\"",
      "\"strings\""
    ],
    "Types": [
      {
        "Kind": "type",
        "Name": "collector",
        "Source": "type collector struct {\n\tfset\t*token.FileSet\n\n\tdefinition\tmap[string]*Definition\n\tseen\t\tmap[string]*Declaration\n}"
      },
      {
        "Kind": "type",
        "Name": "Definition",
        "Source": "type Definition struct {\n\tPackage\tstring\n\n\tImports\t[]string\n\tTypes\tDeclarationList\n\tConsts\tDeclarationList\n\tVars\tDeclarationList\n\tFuncs\tDeclarationList\n}"
      },
      {
        "Kind": "type",
        "Name": "DeclarationKind",
        "Source": "type DeclarationKind string"
      },
      {
        "Kind": "type",
        "Name": "Declaration",
        "Source": "type Declaration struct {\n\tKind\t\tDeclarationKind\n\tName\t\tstring\t\t`json:\",omitempty\"`\n\tNames\t\t[]string\t`json:\",omitempty\"`\n\tReceiver\tstring\t\t`json:\",omitempty\"`\n\tSignature\tstring\t\t`json:\",omitempty\"`\n\tSource\t\tstring\n}"
      },
      {
        "Kind": "type",
        "Name": "DeclarationList",
        "Source": "type DeclarationList []*Declaration"
      }
    ],
    "Consts": [
      {
        "Kind": "const",
        "Names": [
          "StructKind",
          "ImportKind",
          "ConstKind",
          "TypeKind",
          "FuncKind",
          "VarKind",
          "CommentKind"
        ],
        "Source": "const (\n\tStructKind\tDeclarationKind\t= \"struct\"\n\tImportKind\t\t\t= \"import\"\n\tConstKind\t\t\t= \"const\"\n\tTypeKind\t\t\t= \"type\"\n\tFuncKind\t\t\t= \"func\"\n\tVarKind\t\t\t\t= \"var\"\n\tCommentKind\t\t\t= \"comment\"\n)"
      }
    ],
    "Vars": null,
    "Funcs": [
      {
        "Kind": "func",
        "Name": "NewCollector",
        "Signature": "NewCollector (fset *token.FileSet) *collector",
        "Source": "func NewCollector(fset *token.FileSet) *collector {\n\treturn \u0026collector{\n\t\tfset:\t\tfset,\n\t\tdefinition:\tmake(map[string]*Definition),\n\t\tseen:\t\tmake(map[string]*Declaration),\n\t}\n}"
      },
      {
        "Kind": "func",
        "Name": "appendSeen",
        "Receiver": "*collector",
        "Signature": "appendSeen (key string, value *Declaration)",
        "Source": "func (v *collector) appendSeen(key string, value *Declaration) {\n\tif len(value.Names) == 1 {\n\t\tvalue.Name = value.Names[0]\n\t\tvalue.Names = nil\n\t}\n\tv.seen[key] = value\n}"
      },
      {
        "Kind": "func",
        "Name": "isSeen",
        "Receiver": "*collector",
        "Signature": "isSeen (key string) bool",
        "Source": "func (v *collector) isSeen(key string) bool {\n\tdecl, ok := v.seen[key]\n\treturn ok \u0026\u0026 decl != nil\n}"
      },
      {
        "Kind": "func",
        "Name": "collectImports",
        "Receiver": "*collector",
        "Signature": "collectImports (decl *ast.GenDecl, def *Definition)",
        "Source": "func (v *collector) collectImports(decl *ast.GenDecl, def *Definition) {\n\tfor _, spec := range decl.Specs {\n\t\timported, ok := spec.(*ast.ImportSpec)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\timportLiteral := imported.Path.Value\n\t\tif imported.Name != nil {\n\t\t\talias := imported.Name.Name\n\t\t\tfmt.Printf(\"WARN: package %s is aliased to %s\\n\", importLiteral, alias)\n\t\t\timportLiteral = alias + \" \" + importLiteral\n\t\t}\n\n\t\tif !strings.Contains(importLiteral, \"/internal\") {\n\t\t\tif slices.Contains(def.Imports, importLiteral) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdef.Imports = append(def.Imports, importLiteral)\n\t\t}\n\t}\n\n\tsort.Strings(def.Imports)\n}"
      },
      {
        "Kind": "func",
        "Name": "Visit",
        "Receiver": "*collector",
        "Signature": "Visit (node ast.Node, push bool, stack []ast.Node) bool",
        "Source": "func (v *collector) Visit(node ast.Node, push bool, stack []ast.Node) bool {\n\tfile, ok := (stack[0]).(*ast.File)\n\tif !ok {\n\t\treturn true\n\t}\n\n\tpackageName := file.Name.Name\n\tpkg, ok := v.definition[packageName]\n\tif !ok {\n\t\tpkg = \u0026Definition{\n\t\t\tPackage: packageName,\n\t\t}\n\t\tv.definition[packageName] = pkg\n\t}\n\n\tswitch node := node.(type) {\n\tcase *ast.GenDecl:\n\t\tif node.Tok == token.IMPORT {\n\t\t\tv.collectImports(node, pkg)\n\t\t\treturn true\n\t\t}\n\n\t\tfor _, k := range stack {\n\t\t\t_, ok := k.(*ast.FuncDecl)\n\t\t\tif ok {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\tnames := v.Names(node)\n\t\tfor _, name := range names {\n\t\t\tif v.isSeen(packageName + \".\" + name) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\tdef := \u0026Declaration{\n\t\t\tNames:\tnames,\n\t\t\tSource:\tv.getNodeSource(node),\n\t\t}\n\n\t\tfor _, name := range names {\n\t\t\tv.appendSeen(packageName+\".\"+name, def)\n\t\t}\n\n\t\tswitch node.Tok {\n\t\tcase token.CONST:\n\t\t\tdef.Kind = ConstKind\n\t\t\tpkg.Consts.Append(def)\n\t\tcase token.VAR:\n\t\t\tdef.Kind = VarKind\n\t\t\tpkg.Vars.Append(def)\n\t\tcase token.TYPE:\n\t\t\tdef.Kind = TypeKind\n\t\t\tpkg.Types.Append(def)\n\t\t}\n\n\tcase *ast.FuncDecl:\n\t\tdef := v.collectFuncDeclaration(node)\n\t\tif def != nil {\n\t\t\tkey := strings.Trim(packageName+\".\"+def.Receiver+\".\"+def.Name, \"*.\")\n\t\t\tif v.isSeen(key) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tdefer v.appendSeen(key, def)\n\n\t\t\tpkg.Funcs.Append(def)\n\t\t}\n\n\t}\n\n\treturn true\n}"
      },
      {
        "Kind": "func",
        "Name": "Names",
        "Receiver": "*collector",
        "Signature": "Names (decl *ast.GenDecl) []string",
        "Source": "func (v *collector) Names(decl *ast.GenDecl) []string {\n\tnames := make([]string, 0, len(decl.Specs))\n\tfor _, spec := range decl.Specs {\n\t\tif val, ok := spec.(*ast.ValueSpec); ok {\n\t\t\tnames = append(names, v.identNames(val.Names)...)\n\t\t\tcontinue\n\t\t}\n\n\t\tif val, ok := spec.(*ast.TypeSpec); ok {\n\t\t\tnames = append(names, val.Name.Name)\n\t\t\tcontinue\n\t\t}\n\n\t\tv.error(\"warning getting names: unhandled %T\", spec)\n\t}\n\tif len(names) == 0 {\n\t\treturn nil\n\t}\n\treturn names\n}"
      },
      {
        "Kind": "func",
        "Name": "error",
        "Receiver": "*collector",
        "Signature": "error (format string, args ...interface{})",
        "Source": "func (v *collector) error(format string, args ...interface{}) {\n\tfmt.Fprintf(os.Stderr, format+\"\\n\", args...)\n}"
      },
      {
        "Kind": "func",
        "Name": "identNames",
        "Receiver": "*collector",
        "Signature": "identNames (decl []*ast.Ident) []string",
        "Source": "func (v *collector) identNames(decl []*ast.Ident) []string {\n\tif len(decl) == 0 {\n\t\treturn nil\n\t}\n\n\tresult := make([]string, 0, len(decl))\n\tfor _, t := range decl {\n\t\tresult = append(result, t.Name)\n\t}\n\treturn result\n}"
      },
      {
        "Kind": "func",
        "Name": "collectFuncDeclaration",
        "Receiver": "*collector",
        "Signature": "collectFuncDeclaration (decl *ast.FuncDecl) *Declaration",
        "Source": "func (v *collector) collectFuncDeclaration(decl *ast.FuncDecl) *Declaration {\n\tdeclaration := \u0026Declaration{\n\t\tKind:\t\tFuncKind,\n\t\tName:\t\tdecl.Name.Name,\n\t\tSignature:\tv.functionDef(decl),\n\t\tSource:\t\tv.getNodeSource(decl),\n\t}\n\n\tif decl.Recv != nil {\n\t\tvar recvType string\n\t\tswitch t := decl.Recv.List[0].Type.(type) {\n\t\tcase *ast.StarExpr:\n\t\t\trecvType = \"*\" + t.X.(*ast.Ident).Name\n\t\tcase *ast.Ident:\n\t\t\trecvType = t.Name\n\t\t}\n\t\tdeclaration.Receiver = recvType\n\t}\n\n\treturn declaration\n}"
      },
      {
        "Kind": "func",
        "Name": "getNodeSource",
        "Receiver": "*collector",
        "Signature": "getNodeSource (node ast.Node) string",
        "Source": "func (p *collector) getNodeSource(node ast.Node) string {\n\tvar buf strings.Builder\n\terr := printer.Fprint(\u0026buf, p.fset, node)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\treturn buf.String()\n}"
      },
      {
        "Kind": "func",
        "Name": "functionDef",
        "Receiver": "*collector",
        "Signature": "functionDef (fun *ast.FuncDecl) string",
        "Source": "func (p *collector) functionDef(fun *ast.FuncDecl) string {\n\tvar fset = p.fset\n\tname := fun.Name.Name\n\tparams := make([]string, 0)\n\tfor _, p := range fun.Type.Params.List {\n\t\tvar typeNameBuf bytes.Buffer\n\t\terr := printer.Fprint(\u0026typeNameBuf, fset, p.Type)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"failed printing %s\", err)\n\t\t}\n\t\tnames := make([]string, 0)\n\t\tfor _, name := range p.Names {\n\t\t\tnames = append(names, name.Name)\n\t\t}\n\t\tparams = append(params, fmt.Sprintf(\"%s %s\", strings.Join(names, \",\"), typeNameBuf.String()))\n\t}\n\treturns := make([]string, 0)\n\tif fun.Type.Results != nil {\n\t\tfor _, r := range fun.Type.Results.List {\n\t\t\tvar typeNameBuf bytes.Buffer\n\t\t\terr := printer.Fprint(\u0026typeNameBuf, fset, r.Type)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\"failed printing %s\", err)\n\t\t\t}\n\n\t\t\treturns = append(returns, typeNameBuf.String())\n\t\t}\n\t}\n\treturnString := \"\"\n\tif len(returns) == 1 {\n\t\treturnString = returns[0]\n\t} else if len(returns) \u003e 1 {\n\t\treturnString = fmt.Sprintf(\"(%s)\", strings.Join(returns, \", \"))\n\t}\n\n\tparamsString := strings.Join(params, \", \")\n\tif returnString != \"\" {\n\t\treturn fmt.Sprintf(\"%s (%s) %v\", name, paramsString, returnString)\n\t}\n\treturn fmt.Sprintf(\"%s (%s)\", name, paramsString)\n}"
      },
      {
        "Kind": "func",
        "Name": "Keys",
        "Receiver": "*Declaration",
        "Signature": "Keys () []string",
        "Source": "func (d *Declaration) Keys() []string {\n\ttrimPath := \"*.\"\n\tif d.Name != \"\" {\n\t\treturn []string{\n\t\t\tstrings.Trim(d.Receiver+\".\"+d.Name, trimPath),\n\t\t}\n\t}\n\tif len(d.Names) != 0 {\n\t\tresult := make([]string, len(d.Names))\n\t\tfor k, v := range d.Names {\n\t\t\tresult[k] = strings.Trim(d.Receiver+\".\"+v, trimPath)\n\t\t}\n\t}\n\treturn nil\n}"
      },
      {
        "Kind": "func",
        "Name": "Append",
        "Receiver": "*DeclarationList",
        "Signature": "Append (in *Declaration)",
        "Source": "func (p *DeclarationList) Append(in *Declaration) {\n\t*p = append(*p, in)\n}"
      },
      {
        "Kind": "func",
        "Name": "Load",
        "Signature": "Load (sourcePath string) ([]*Definition, error)",
        "Source": "// Load definitions from package located in sourcePath.\nfunc Load(sourcePath string) ([]*Definition, error) {\n\tfset := token.NewFileSet()\n\n\tpackages, err := parser.ParseDir(fset, sourcePath, nil, parser.ParseComments)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfiles := []*ast.File{}\n\tfor _, pkg := range packages {\n\t\tfor _, file := range pkg.Files {\n\t\t\tfiles = append(files, file)\n\t\t}\n\t}\n\n\tcollector := NewCollector(fset)\n\n\tinsp := inspector.New(files)\n\tinsp.WithStack(nil, collector.Visit)\n\n\tresults := make([]*Definition, 0, len(collector.definition))\n\tfor _, pkg := range collector.definition {\n\t\tresults = append(results, pkg)\n\t}\n\treturn results, nil\n}"
      }
    ]
  },
  {
    "Package": "model_test",
    "Imports": [
      "\"github.com/TykTechnologies/exp/cmd/go-fsck/model\"",
      "\"github.com/kortschak/utter\"",
      "\"github.com/stretchr/testify/assert\"",
      "\"testing\""
    ],
    "Types": null,
    "Consts": null,
    "Vars": null,
    "Funcs": [
      {
        "Kind": "func",
        "Name": "TestLoad",
        "Signature": "TestLoad (t *testing.T)",
        "Source": "func TestLoad(t *testing.T) {\n\tutter.Config.IgnoreUnexported = true\n\tutter.Config.OmitZero = true\n\tutter.Config.ElideType = true\n\n\tdefs, err := model.Load(\".\")\n\tassert.NoError(t, err)\n\tassert.NotNil(t, defs)\n\n\tutter.Dump(defs)\n}"
      }
    ]
  }
]