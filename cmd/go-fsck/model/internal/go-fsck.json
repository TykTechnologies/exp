[
  {
    "Package": "internal",
    "Doc": null,
    "Imports": {
      "ast.go": [
        "\"go/ast\"",
        "\"go/printer\"",
        "\"go/token\"",
        "\"io\""
      ]
    },
    "Types": null,
    "Consts": null,
    "Vars": null,
    "Funcs": [
      {
        "Kind": "func",
        "File": "ast.go",
        "SelfContained": false,
        "Name": "CommentedNode",
        "Arguments": [
          "*ast.File",
          "any"
        ],
        "Returns": [
          "*printer.CommentedNode"
        ],
        "Signature": "CommentedNode (file *ast.File, node any) *printer.CommentedNode",
        "Source": "func CommentedNode(file *ast.File, node any) *printer.CommentedNode {\n\treturn \u0026printer.CommentedNode{\n\t\tNode:\t\tnode,\n\t\tComments:\tfile.Comments,\n\t}\n}"
      },
      {
        "Kind": "func",
        "File": "ast.go",
        "SelfContained": false,
        "Name": "ContainsOtherTypes",
        "Arguments": [
          "ast.Expr"
        ],
        "Returns": [
          "bool"
        ],
        "Signature": "ContainsOtherTypes (expr ast.Expr) bool",
        "Source": "func ContainsOtherTypes(expr ast.Expr) bool {\n\tswitch t := expr.(type) {\n\tcase *ast.Ident:\n\t\t// It's an identifier; check if it's referring to another type/package.\n\t\tif t.Obj != nil \u0026\u0026 t.Obj.Kind == ast.Typ {\n\t\t\treturn true\t// It's referring to another type/package.\n\t\t}\n\tcase *ast.SelectorExpr:\n\t\t// It's a selector expression; check if it's referring to another package.\n\t\treturn true\n\t\t// Add cases for other types you want to handle.\n\t}\n\n\treturn false\n}"
      },
      {
        "Kind": "func",
        "File": "ast.go",
        "SelfContained": false,
        "Name": "IsSelfContainedType",
        "Arguments": [
          "*ast.GenDecl"
        ],
        "Returns": [
          "bool"
        ],
        "Signature": "IsSelfContainedType (genDecl *ast.GenDecl) bool",
        "Source": "func IsSelfContainedType(genDecl *ast.GenDecl) bool {\n\tswitch genDecl.Tok {\n\tcase token.TYPE:\n\t\tfor _, spec := range genDecl.Specs {\n\t\t\tif typeSpec, ok := spec.(*ast.TypeSpec); ok {\n\t\t\t\tswitch t := typeSpec.Type.(type) {\n\t\t\t\tcase *ast.StructType:\n\t\t\t\t\t// It's a struct type, check if it references other types/packages.\n\t\t\t\t\tfor _, f := range t.Fields.List {\n\t\t\t\t\t\tif ContainsOtherTypes(f.Type) {\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase *ast.InterfaceType:\n\t\t\t\t\t// It's an interface type, check if it references other types/packages.\n\t\t\t\t\tfor _, f := range t.Methods.List {\n\t\t\t\t\t\tif ContainsOtherTypes(f.Type) {\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t// Add other cases for any other self-contained types you want to support,\n\t\t\t\t// like arrays, slices, etc., or return false if the type is not supported.\n\t\t\t\tdefault:\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// There is a non-type spec in the GenDecl (e.g., a variable or constant declaration).\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tcase token.VAR, token.CONST:\n\t\tfor _, spec := range genDecl.Specs {\n\t\t\tif valueSpec, ok := spec.(*ast.ValueSpec); ok {\n\t\t\t\t// Check if the variable/constant type references other types/packages.\n\t\t\t\tif ContainsOtherTypes(valueSpec.Type) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// There is a non-value spec in the GenDecl.\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\tdefault:\n\t\t// The GenDecl is not a type, variable, or constant declaration.\n\t\treturn false\n\t}\n\n\t// All specs are self-contained types, variables, or constants.\n\treturn true\n}"
      },
      {
        "Kind": "func",
        "File": "ast.go",
        "SelfContained": false,
        "Name": "PrintSource",
        "Arguments": [
          "*printer.CommentedNode",
          "*token.FileSet",
          "io.Writer"
        ],
        "Returns": [
          "error"
        ],
        "Signature": "PrintSource (val *printer.CommentedNode, fset *token.FileSet, out io.Writer) error",
        "Source": "func PrintSource(val *printer.CommentedNode, fset *token.FileSet, out io.Writer) error {\n\treturn printer.Fprint(out, fset, val)\n}"
      }
    ]
  },
  {
    "Package": "internal_test",
    "Doc": null,
    "Imports": {
      "ast_test.go": [
        "\"go/parser\"",
        "\"go/token\"",
        "\"strings\"",
        "\"testing\"",
        "\"github.com/stretchr/testify/assert\"",
        "\"github.com/TykTechnologies/exp/cmd/go-fsck/model/internal\""
      ]
    },
    "Types": null,
    "Consts": [
      {
        "Kind": "const",
        "File": "ast_test.go",
        "SelfContained": true,
        "Name": "src",
        "Source": "const src = `package example\n\n// Global func comment\nfunc GlobalFunc() error {\n\t// holds the error\n\tvar err error\t// the err var\n\n\t// inline comment\n\terr = nil\n\n\treturn err\n}`"
      }
    ],
    "Vars": null,
    "Funcs": [
      {
        "Kind": "func",
        "File": "ast_test.go",
        "SelfContained": false,
        "Name": "TestPrint",
        "Arguments": [
          "*testing.T"
        ],
        "Signature": "TestPrint (t *testing.T)",
        "Source": "func TestPrint(t *testing.T) {\n\tfset := token.NewFileSet()\n\tf, err := parser.ParseFile(fset, \"\", src, parser.ParseComments)\n\tassert.NoError(t, err)\n\n\tvar out strings.Builder\n\tassert.NoError(t, internal.PrintSource(internal.CommentedNode(f, f), fset, \u0026out))\n\n\tassert.Equal(t, src, strings.TrimSpace(out.String()))\n}"
      }
    ]
  }
]