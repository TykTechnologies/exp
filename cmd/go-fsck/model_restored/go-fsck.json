[
  {
    "Package": "model",
    "Doc": null,
    "Imports": {
      "build_tags.go": [
        "\"regexp\"",
        "\"strings\""
      ],
      "collector.go": [
        "\"bytes\"",
        "\"fmt\"",
        "\"go/ast\"",
        "\"go/printer\"",
        "\"go/token\"",
        "\"log\"",
        "\"os\"",
        "\"path\"",
        "\"regexp\"",
        "\"strings\""
      ],
      "definition.go": [
        "\"sort\"",
        "\"strings\"",
        "\"golang.org/x/exp/slices\""
      ],
      "load.go": [
        "\"encoding/json\"",
        "\"fmt\"",
        "\"go/ast\"",
        "\"go/parser\"",
        "\"go/token\"",
        "\"os\"",
        "\"path\"",
        "\"sort\"",
        "\"golang.org/x/tools/go/ast/inspector\""
      ]
    },
    "Types": [
      {
        "Kind": "type",
        "File": "definition.go",
        "Name": "Definition",
        "Source": "type (\n\tDefinition struct {\n\t\tPackage\tstring\n\t\tDoc\tStringSet\n\t\tImports\tStringSet\n\t\tTypes\tDeclarationList\n\t\tConsts\tDeclarationList\n\t\tVars\tDeclarationList\n\t\tFuncs\tDeclarationList\n\t}\n)"
      },
      {
        "Kind": "type",
        "File": "definition.go",
        "Name": "StringSet",
        "Source": "type StringSet map[string][]string"
      },
      {
        "Kind": "type",
        "File": "definition.go",
        "Names": [
          "DeclarationKind",
          "Declaration"
        ],
        "Source": "type (\n\tDeclarationKind\tstring\n\n\tDeclaration\tstruct {\n\t\tKind\t\tDeclarationKind\n\t\tFile\t\tstring\n\t\tImports\t\t[]string\t`json:\",omitempty\"`\n\t\tName\t\tstring\t\t`json:\",omitempty\"`\n\t\tNames\t\t[]string\t`json:\",omitempty\"`\n\t\tReceiver\tstring\t\t`json:\",omitempty\"`\n\t\tSignature\tstring\t\t`json:\",omitempty\"`\n\t\tSource\t\tstring\n\t}\n)"
      },
      {
        "Kind": "type",
        "File": "definition.go",
        "Name": "DeclarationList",
        "Source": "type DeclarationList []*Declaration"
      },
      {
        "Kind": "type",
        "File": "collector.go",
        "Name": "collector",
        "Source": "type collector struct {\n\tfset\t*token.FileSet\n\n\tdefinition\tmap[string]*Definition\n\tseen\t\tmap[string]*Declaration\n}"
      }
    ],
    "Consts": [
      {
        "Kind": "const",
        "File": "definition.go",
        "Names": [
          "StructKind",
          "ImportKind",
          "ConstKind",
          "TypeKind",
          "FuncKind",
          "VarKind",
          "CommentKind"
        ],
        "Source": "const (\n\tStructKind\tDeclarationKind\t= \"struct\"\n\tImportKind\t\t\t= \"import\"\n\tConstKind\t\t\t= \"const\"\n\tTypeKind\t\t\t= \"type\"\n\tFuncKind\t\t\t= \"func\"\n\tVarKind\t\t\t\t= \"var\"\n\tCommentKind\t\t\t= \"comment\"\n)"
      }
    ],
    "Vars": null,
    "Funcs": [
      {
        "Kind": "func",
        "File": "definition.go",
        "Name": "String",
        "Receiver": "DeclarationKind",
        "Signature": "String () string",
        "Source": "func (d DeclarationKind) String() string {\n\treturn string(d)\n}"
      },
      {
        "Kind": "func",
        "File": "definition.go",
        "Name": "getImports",
        "Receiver": "*Definition",
        "Signature": "getImports (decl *Declaration) []string",
        "Source": "func (d *Definition) getImports(decl *Declaration) []string {\n\treturn d.Imports.Get(decl.File)\n}"
      },
      {
        "Kind": "func",
        "File": "definition.go",
        "Name": "Order",
        "Receiver": "*Definition",
        "Signature": "Order () []*Declaration",
        "Source": "func (d *Definition) Order() []*Declaration {\n\tcount := len(d.Types) + len(d.Funcs) + len(d.Vars) + len(d.Consts)\n\tresult := make([]*Declaration, 0, count)\n\n\tresult = append(result, d.Types...)\n\tresult = append(result, d.Funcs...)\n\tresult = append(result, d.Vars...)\n\tresult = append(result, d.Consts...)\n\treturn result\n}"
      },
      {
        "Kind": "func",
        "File": "definition.go",
        "Name": "Fill",
        "Receiver": "*Definition",
        "Signature": "Fill ()",
        "Source": "func (d *Definition) Fill() {\n\tfor _, decl := range d.Order() {\n\t\tdecl.Imports = d.getImports(decl)\n\t}\n}"
      },
      {
        "Kind": "func",
        "File": "definition.go",
        "Name": "Keys",
        "Receiver": "*Declaration",
        "Signature": "Keys () []string",
        "Source": "func (d *Declaration) Keys() []string {\n\ttrimPath := \"*.\"\n\tif d.Name != \"\" {\n\t\treturn []string{\n\t\t\tstrings.Trim(d.Receiver+\".\"+d.Name, trimPath),\n\t\t}\n\t}\n\tif len(d.Names) != 0 {\n\t\tresult := make([]string, len(d.Names))\n\t\tfor k, v := range d.Names {\n\t\t\tresult[k] = strings.Trim(d.Receiver+\".\"+v, trimPath)\n\t\t}\n\t}\n\treturn nil\n}"
      },
      {
        "Kind": "func",
        "File": "definition.go",
        "Name": "Add",
        "Receiver": "*StringSet",
        "Signature": "Add (key,lit string)",
        "Source": "func (i *StringSet) Add(key, lit string) {\n\tdata := *i\n\tif data == nil {\n\t\tdata = make(StringSet)\n\t}\n\tif set, ok := data[key]; ok {\n\t\tif slices.Contains(set, lit) {\n\t\t\treturn\n\t\t}\n\t\tdata[key] = append(set, lit)\n\t\treturn\n\t}\n\tdata[key] = []string{lit}\n\t*i = data\n}"
      },
      {
        "Kind": "func",
        "File": "definition.go",
        "Name": "Get",
        "Receiver": "StringSet",
        "Signature": "Get (key string) []string",
        "Source": "func (i StringSet) Get(key string) []string {\n\tval, _ := i[key]\n\tif val != nil {\n\t\tsort.Strings(val)\n\t}\n\treturn val\n}"
      },
      {
        "Kind": "func",
        "File": "definition.go",
        "Name": "All",
        "Receiver": "StringSet",
        "Signature": "All () []string",
        "Source": "func (i StringSet) All() []string {\n\tresult := []string{}\n\tfor _, set := range i {\n\t\tresult = append(result, set...)\n\t}\n\treturn result\n}"
      },
      {
        "Kind": "func",
        "File": "definition.go",
        "Name": "Append",
        "Receiver": "*DeclarationList",
        "Signature": "Append (in *Declaration)",
        "Source": "func (p *DeclarationList) Append(in *Declaration) {\n\t*p = append(*p, in)\n}"
      },
      {
        "Kind": "func",
        "File": "load.go",
        "Name": "Load",
        "Signature": "Load (sourcePath string) ([]*Definition, error)",
        "Source": "// Load definitions from package located in sourcePath.\nfunc Load(sourcePath string) ([]*Definition, error) {\n\tfset := token.NewFileSet()\n\n\tpackages, err := parser.ParseDir(fset, sourcePath, nil, parser.ParseComments)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfiles := []*ast.File{}\n\tfor _, pkg := range packages {\n\t\tfor _, file := range pkg.Files {\n\t\t\tfilename := path.Base(fset.Position(file.Pos()).Filename)\n\n\t\t\tsrc, err := os.ReadFile(path.Join(sourcePath, filename))\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"Error reading in source file: %s\", filename)\n\t\t\t}\n\n\t\t\ttags := BuildTags(src)\n\t\t\tif len(tags) == 0 {\n\t\t\t\tfiles = append(files, file)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfmt.Printf(\"WARN: Skipping file %s with build tags: %v\\n\", filename, tags)\n\t\t}\n\t}\n\n\tcollector := NewCollector(fset)\n\n\tinsp := inspector.New(files)\n\tinsp.WithStack(nil, collector.Visit)\n\n\tcollector.Clean()\n\n\tresults := make([]*Definition, 0, len(collector.definition))\n\tpkgNames := make([]string, 0, len(collector.definition))\n\tfor _, pkg := range collector.definition {\n\t\tpkgNames = append(pkgNames, pkg.Package)\n\t}\n\tsort.Strings(pkgNames)\n\n\tfor _, pkg := range collector.definition {\n\t\tfor _, name := range pkgNames {\n\t\t\tif pkg.Package == name {\n\t\t\t\tresults = append(results, pkg)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn results, nil\n}"
      },
      {
        "Kind": "func",
        "File": "load.go",
        "Name": "ReadFile",
        "Signature": "ReadFile (inputPath string) ([]*Definition, error)",
        "Source": "// ReadFile loads the definitions from a json file\nfunc ReadFile(inputPath string) ([]*Definition, error) {\n\tdata, err := os.ReadFile(inputPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar result []*Definition\n\tif err := json.Unmarshal(data, \u0026result); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, decl := range result {\n\t\tdecl.Fill()\n\t}\n\n\treturn result, nil\n}"
      },
      {
        "Kind": "func",
        "File": "build_tags.go",
        "Name": "BuildTags",
        "Signature": "BuildTags (src []byte) []string",
        "Source": "func BuildTags(src []byte) []string {\n\n\tre := regexp.MustCompile(`(?m)^\\s*//\\s*\\+build\\s+(.*)$`)\n\n\tvar buildTags []string\n\n\tmatches := re.FindAllStringSubmatch(string(src), -1)\n\tfor _, match := range matches {\n\t\tbuildTag := strings.TrimSpace(match[1])\n\t\tbuildTags = append(buildTags, buildTag)\n\t}\n\n\treturn buildTags\n}"
      },
      {
        "Kind": "func",
        "File": "collector.go",
        "Name": "NewCollector",
        "Signature": "NewCollector (fset *token.FileSet) *collector",
        "Source": "func NewCollector(fset *token.FileSet) *collector {\n\treturn \u0026collector{\n\t\tfset:\t\tfset,\n\t\tdefinition:\tmake(map[string]*Definition),\n\t\tseen:\t\tmake(map[string]*Declaration),\n\t}\n}"
      },
      {
        "Kind": "func",
        "File": "collector.go",
        "Name": "Clean",
        "Receiver": "*collector",
        "Signature": "Clean ()",
        "Source": "func (v *collector) Clean() {\n\tfor _, def := range v.definition {\n\t\timports := []string{}\n\t\taliases := map[string]string{}\n\n\t\talias := func(alias, dest string) bool {\n\t\t\tval, ok := aliases[alias]\n\t\t\tif ok {\n\t\t\t\tif val != dest {\n\t\t\t\t\tfmt.Printf(\"WARN: Alias mismatch: %s\\n%s (prev) != %s (new)\\n\", alias, val, dest)\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\n\t\t\taliases[alias] = dest\n\t\t\timports = append(imports, dest)\n\t\t\treturn true\n\t\t}\n\n\t\tfor _, imported := range def.Imports.All() {\n\t\t\tif strings.Contains(imported, \" \") {\n\t\t\t\tline := strings.Split(imported, \" \")\n\t\t\t\talias(line[0], strings.Trim(line[1], `\"`))\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\talias(path.Base(imported), strings.Trim(imported, `\"`))\n\t\t}\n\t}\n}"
      },
      {
        "Kind": "func",
        "File": "collector.go",
        "Name": "appendSeen",
        "Receiver": "*collector",
        "Signature": "appendSeen (key string, value *Declaration)",
        "Source": "func (v *collector) appendSeen(key string, value *Declaration) {\n\tif len(value.Names) == 1 {\n\t\tvalue.Name = value.Names[0]\n\t\tvalue.Names = nil\n\t}\n\tv.seen[key] = value\n}"
      },
      {
        "Kind": "func",
        "File": "collector.go",
        "Name": "isSeen",
        "Receiver": "*collector",
        "Signature": "isSeen (key string) bool",
        "Source": "func (v *collector) isSeen(key string) bool {\n\tdecl, ok := v.seen[key]\n\treturn ok \u0026\u0026 decl != nil\n}"
      },
      {
        "Kind": "func",
        "File": "collector.go",
        "Name": "collectImports",
        "Receiver": "*collector",
        "Signature": "collectImports (filename string, decl *ast.GenDecl, def *Definition)",
        "Source": "func (v *collector) collectImports(filename string, decl *ast.GenDecl, def *Definition) {\n\tfor _, spec := range decl.Specs {\n\t\timported, ok := spec.(*ast.ImportSpec)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\timportLiteral := imported.Path.Value\n\t\timportClean := strings.Trim(importLiteral, `*`)\n\t\tif imported.Name != nil {\n\t\t\talias := imported.Name.Name\n\t\t\tbase := path.Base(importClean)\n\t\t\tswitch alias {\n\t\t\tcase base:\n\t\t\t\tfmt.Printf(\"WARN: removing %s alias for %s)\\n\", alias, importClean)\n\t\t\tcase \"_\":\n\n\t\t\tdefault:\n\t\t\t\tfmt.Printf(\"WARN: package %s is aliased to %s\\n\", importLiteral, alias)\n\t\t\t\timportLiteral = alias + \" \" + importLiteral\n\t\t\t}\n\t\t}\n\n\t\tdef.Imports.Add(filename, importLiteral)\n\t}\n}"
      },
      {
        "Kind": "func",
        "File": "collector.go",
        "Name": "Visit",
        "Receiver": "*collector",
        "Signature": "Visit (node ast.Node, push bool, stack []ast.Node) bool",
        "Source": "func (v *collector) Visit(node ast.Node, push bool, stack []ast.Node) bool {\n\tfile, ok := (stack[0]).(*ast.File)\n\tif !ok {\n\t\treturn true\n\t}\n\tfilename := path.Base(v.fset.Position(file.Pos()).Filename)\n\n\tpackageName := file.Name.Name\n\n\tpkg, ok := v.definition[packageName]\n\tif !ok {\n\t\tpkg = \u0026Definition{\n\t\t\tPackage: packageName,\n\t\t}\n\t\tv.definition[packageName] = pkg\n\t}\n\n\tif file.Doc != nil {\n\t\tpkg.Doc.Add(filename, v.getSource(file.Doc.List))\n\t}\n\n\tswitch node := node.(type) {\n\tcase *ast.GenDecl:\n\t\tif node.Tok == token.IMPORT {\n\t\t\tv.collectImports(filename, node, pkg)\n\t\t\treturn true\n\t\t}\n\n\t\tfor _, k := range stack {\n\t\t\t_, ok := k.(*ast.FuncDecl)\n\t\t\tif ok {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\tnames := v.Names(node)\n\t\tfor _, name := range names {\n\t\t\tif v.isSeen(packageName + \".\" + name) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\n\t\tdef := \u0026Declaration{\n\t\t\tNames:\tnames,\n\t\t\tFile:\tfilename,\n\t\t\tSource:\tv.getSource(node),\n\t\t}\n\n\t\tfor _, name := range names {\n\t\t\tv.appendSeen(packageName+\".\"+name, def)\n\t\t}\n\n\t\tswitch node.Tok {\n\t\tcase token.CONST:\n\t\t\tdef.Kind = ConstKind\n\t\t\tpkg.Consts.Append(def)\n\t\tcase token.VAR:\n\t\t\tdef.Kind = VarKind\n\t\t\tpkg.Vars.Append(def)\n\t\tcase token.TYPE:\n\t\t\tdef.Kind = TypeKind\n\t\t\tpkg.Types.Append(def)\n\t\t}\n\n\tcase *ast.FuncDecl:\n\t\tdef := v.collectFuncDeclaration(node, filename)\n\t\tif def != nil {\n\t\t\tkey := strings.Trim(packageName+\".\"+def.Receiver+\".\"+def.Name, \"*.\")\n\t\t\tif v.isSeen(key) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tdefer v.appendSeen(key, def)\n\n\t\t\tpkg.Funcs.Append(def)\n\t\t}\n\n\t}\n\n\treturn true\n}"
      },
      {
        "Kind": "func",
        "File": "collector.go",
        "Name": "Names",
        "Receiver": "*collector",
        "Signature": "Names (decl *ast.GenDecl) []string",
        "Source": "func (v *collector) Names(decl *ast.GenDecl) []string {\n\tnames := make([]string, 0, len(decl.Specs))\n\tfor _, spec := range decl.Specs {\n\t\tif val, ok := spec.(*ast.ValueSpec); ok {\n\t\t\tnames = append(names, v.identNames(val.Names)...)\n\t\t\tcontinue\n\t\t}\n\n\t\tif val, ok := spec.(*ast.TypeSpec); ok {\n\t\t\tnames = append(names, val.Name.Name)\n\t\t\tcontinue\n\t\t}\n\n\t\tv.error(\"warning getting names: unhandled %T\", spec)\n\t}\n\tif len(names) == 0 {\n\t\treturn nil\n\t}\n\treturn names\n}"
      },
      {
        "Kind": "func",
        "File": "collector.go",
        "Name": "error",
        "Receiver": "*collector",
        "Signature": "error (format string, args ...interface{})",
        "Source": "func (v *collector) error(format string, args ...interface{}) {\n\tfmt.Fprintf(os.Stderr, format+\"\\n\", args...)\n}"
      },
      {
        "Kind": "func",
        "File": "collector.go",
        "Name": "identNames",
        "Receiver": "*collector",
        "Signature": "identNames (decl []*ast.Ident) []string",
        "Source": "func (v *collector) identNames(decl []*ast.Ident) []string {\n\tif len(decl) == 0 {\n\t\treturn nil\n\t}\n\n\tresult := make([]string, 0, len(decl))\n\tfor _, t := range decl {\n\t\tresult = append(result, t.Name)\n\t}\n\treturn result\n}"
      },
      {
        "Kind": "func",
        "File": "collector.go",
        "Name": "collectFuncDeclaration",
        "Receiver": "*collector",
        "Signature": "collectFuncDeclaration (decl *ast.FuncDecl, filename string) *Declaration",
        "Source": "func (v *collector) collectFuncDeclaration(decl *ast.FuncDecl, filename string) *Declaration {\n\tdeclaration := \u0026Declaration{\n\t\tKind:\t\tFuncKind,\n\t\tFile:\t\tfilename,\n\t\tName:\t\tdecl.Name.Name,\n\t\tSignature:\tv.functionDef(decl),\n\t\tSource:\t\tv.getSource(decl),\n\t}\n\n\tif decl.Recv != nil {\n\t\tvar recvType string\n\t\tswitch t := decl.Recv.List[0].Type.(type) {\n\t\tcase *ast.StarExpr:\n\t\t\trecvType = \"*\" + t.X.(*ast.Ident).Name\n\t\tcase *ast.Ident:\n\t\t\trecvType = t.Name\n\t\t}\n\t\tdeclaration.Receiver = recvType\n\t}\n\n\treturn declaration\n}"
      },
      {
        "Kind": "func",
        "File": "collector.go",
        "Name": "getSource",
        "Receiver": "*collector",
        "Signature": "getSource (node any) string",
        "Source": "func (p *collector) getSource(node any) string {\n\tvar buf strings.Builder\n\terr := printer.Fprint(\u0026buf, p.fset, node)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\treturn buf.String()\n}"
      },
      {
        "Kind": "func",
        "File": "collector.go",
        "Name": "functionDef",
        "Receiver": "*collector",
        "Signature": "functionDef (fun *ast.FuncDecl) string",
        "Source": "func (p *collector) functionDef(fun *ast.FuncDecl) string {\n\tvar fset = p.fset\n\tname := fun.Name.Name\n\tparams := make([]string, 0)\n\tfor _, p := range fun.Type.Params.List {\n\t\tvar typeNameBuf bytes.Buffer\n\t\terr := printer.Fprint(\u0026typeNameBuf, fset, p.Type)\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"failed printing %s\", err)\n\t\t}\n\t\tnames := make([]string, 0)\n\t\tfor _, name := range p.Names {\n\t\t\tnames = append(names, name.Name)\n\t\t}\n\t\tparams = append(params, fmt.Sprintf(\"%s %s\", strings.Join(names, \",\"), typeNameBuf.String()))\n\t}\n\treturns := make([]string, 0)\n\tif fun.Type.Results != nil {\n\t\tfor _, r := range fun.Type.Results.List {\n\t\t\tvar typeNameBuf bytes.Buffer\n\t\t\terr := printer.Fprint(\u0026typeNameBuf, fset, r.Type)\n\t\t\tif err != nil {\n\t\t\t\tlog.Fatalf(\"failed printing %s\", err)\n\t\t\t}\n\n\t\t\treturns = append(returns, typeNameBuf.String())\n\t\t}\n\t}\n\treturnString := \"\"\n\tif len(returns) == 1 {\n\t\treturnString = returns[0]\n\t} else if len(returns) \u003e 1 {\n\t\treturnString = fmt.Sprintf(\"(%s)\", strings.Join(returns, \", \"))\n\t}\n\n\tparamsString := strings.Join(params, \", \")\n\tif returnString != \"\" {\n\t\treturn fmt.Sprintf(\"%s (%s) %v\", name, paramsString, returnString)\n\t}\n\treturn fmt.Sprintf(\"%s (%s)\", name, paramsString)\n}"
      },
      {
        "Kind": "func",
        "File": "collector.go",
        "Name": "getBuildTags",
        "Signature": "getBuildTags (file *ast.File) []string",
        "Source": "func getBuildTags(file *ast.File) []string {\n\n\tre := regexp.MustCompile(`^\\s*//\\s*\\+build\\s+(.*)$`)\n\n\tvar buildTags []string\n\n\tif file.Doc != nil {\n\t\tfor _, comment := range file.Doc.List {\n\t\t\tmatch := re.FindStringSubmatch(comment.Text)\n\t\t\tif len(match) \u003e 1 {\n\t\t\t\tbuildTags = append(buildTags, match[1])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn buildTags\n}"
      }
    ]
  },
  {
    "Package": "model_test",
    "Doc": null,
    "Imports": {
      "load_test.go": [
        "\"testing\"",
        "\"github.com/kortschak/utter\"",
        "\"github.com/stretchr/testify/assert\"",
        "\"github.com/TykTechnologies/exp/cmd/go-fsck/model\""
      ]
    },
    "Types": null,
    "Consts": null,
    "Vars": null,
    "Funcs": [
      {
        "Kind": "func",
        "File": "load_test.go",
        "Name": "TestLoad",
        "Signature": "TestLoad (t *testing.T)",
        "Source": "func TestLoad(t *testing.T) {\n\tutter.Config.IgnoreUnexported = true\n\tutter.Config.OmitZero = true\n\tutter.Config.ElideType = true\n\n\tdefs, err := model.Load(\".\")\n\tassert.NoError(t, err)\n\tassert.NotNil(t, defs)\n\n}"
      }
    ]
  }
]