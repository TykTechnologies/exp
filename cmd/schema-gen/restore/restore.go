package restore

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"strings"

	"golang.org/x/exp/slices"

	"github.com/TykTechnologies/exp/cmd/schema-gen/model"
)

func restore(cfg *options) error {
	// unpack options into scope
	var (
		inputFile  = cfg.inputFile
		outputFile = cfg.outputFile
	)

	pkgInfo, err := model.Load(inputFile)
	if err != nil {
		return fmt.Errorf("Error loading package info: %w", err)
	}

	body, err := restorePackageInfo(pkgInfo, cfg)
	if err != nil {
		return err
	}

	fmt.Println(outputFile)
	return os.WriteFile(outputFile, body, 0644)
}

func restorePackageInfo(pkgInfo *model.PackageInfo, cfg *options) ([]byte, error) {
	var output bytes.Buffer

	canRender := func(name string) bool {
		if len(cfg.keep) == 0 {
			return true
		}
		return slices.Contains(cfg.keep, name)
	}

	output.WriteString("package " + cfg.packageName + "\n\n")
	output.WriteString("// This code is autogenerated by exp/cmd/schema-gen, do not modify.\n\n")

	if len(pkgInfo.Imports) > 0 {
		output.WriteString("import (")
		for _, importLiteral := range pkgInfo.Imports {
			output.WriteString("\n\t" + importLiteral)
		}
		output.WriteString("\n)\n\n")
	}

	// Dump out filedocs
	for _, decl := range pkgInfo.Declarations {
		if decl.FileDoc != "" {
			output.WriteString("/*\n" + decl.FileDoc + "\n*/\n\n")
		}
	}

	// Dump out declarations
	for _, decl := range pkgInfo.Declarations {
		filtered := model.TypeList{}
		for _, typeDecl := range decl.Types {
			if !canRender(typeDecl.Name) {
				continue
			}
			filtered = append(filtered, typeDecl)
		}
		decl.Types = filtered

		if len(decl.Types) == 0 {
			continue
		}

		if decl.Doc != "" {
			printDoc(&output, decl.Doc)
		}

		if len(decl.Types) == 1 && decl.Types[0].Doc == "" {
			typeDecl := decl.Types[0]
			if typeDecl.Type != "" {
				output.WriteString("type " + typeDecl.Name)

				// This is likely wrong, but also an edge case.
				// We should not import third party data models.
				if strings.Contains(typeDecl.Type, ".") {
					output.WriteString(fmt.Sprintf(" = %s", typeDecl.Type))
				} else {
					output.WriteString(" " + typeDecl.Type)
				}

				if typeDecl.Comment != "" {
					output.WriteString(fmt.Sprintf(" // %s", typeDecl.Comment))
				}
				output.WriteString("\n")
				goto includeFunctions
			}

			output.WriteString("type ")
			printStruct(&output, typeDecl)
			output.WriteString("\n\n")
		} else {
			output.WriteString("type (")
			for idx, typeDecl := range decl.Types {
				printDoc(&output, typeDecl.Doc)

				// Generic type declaration
				if typeDecl.Type != "" {
					// Type declaration
					output.WriteString(fmt.Sprintf("\n%s = %s", typeDecl.Name, typeDecl.Type))
					if idx+1 < len(decl.Types) {
						output.WriteString("\n")
					}
					continue
				}

				printStruct(&output, typeDecl)
				output.WriteString("\n\n")
			}
			output.WriteString(")\n\n")
		}

	includeFunctions:
		for _, typeDecl := range decl.Types {
			for _, funcDecl := range typeDecl.Functions {
				if slices.Contains(cfg.includeFunctions, funcDecl.Name) {
					output.WriteString(funcDecl.Source + "\n\n")
				}
			}
		}
	}

	contents, err := format.Source(output.Bytes())
	if err != nil {
		fmt.Println("Error formatting source:", err)
		return output.Bytes(), nil
	}
	return contents, nil
}

func printStruct(output *bytes.Buffer, typeDecl *model.TypeInfo) {
	// Struct type declaration
	output.WriteString(fmt.Sprintf("%s struct {", typeDecl.Name))
	for _, fieldDecl := range typeDecl.Fields {
		// Field doc
		printDoc(output, fieldDecl.Doc)

		// Field declaration
		output.WriteString(fmt.Sprintf("%s %s", fieldDecl.Name, fieldDecl.Type))
		if fieldDecl.Tag != "" {
			output.WriteString(fmt.Sprintf(" `%s`", fieldDecl.Tag))
		}
		if fieldDecl.Comment != "" {
			output.WriteString(fmt.Sprintf(" // %s", fieldDecl.Comment))
		}
		output.WriteString("\n")
	}
	output.WriteString("}")
}

func printDoc(output *bytes.Buffer, comment string) {
	if comment == "" {
		output.WriteString("\n")
		return
	}

	lines := strings.Split(comment, "\n")
	for _, line := range lines {
		line = " " + strings.TrimSpace(line)
		output.WriteString("\n//" + line)
	}
	output.WriteString("\n")
}
